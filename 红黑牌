solution 1

@lru_cache(maxsize=None)
def V(r, b):
    # 边界条件
    if r == 0:
        return 0
    if b == 0:
        return r  # 只剩红牌，全抽完
    
    # 继续抽牌的期望收益
    expected = (r / (r + b)) * (1 + V(r - 1, b)) + (b / (r + b)) * (-1 + V(r, b - 1))
    
    # 可以随时停止
    return max(0, expected)


solution 2 反向dp 已知终局推现在
def V_dp(R, B):
    # 创建 DP 表，初始化为 0
    dp = [[0.0 for _ in range(B + 1)] for _ in range(R + 1)]
    
    # 初始化边界条件
    for r in range(R + 1):
        dp[r][0] = r   # 只剩红牌
    for b in range(B + 1):
        dp[0][b] = 0   # 只剩黑牌
    
    # 填表：从小到大
    for r in range(1, R + 1):
        for b in range(1, B + 1):
            expected = (r / (r + b)) * (1 + dp[r - 1][b]) + (b / (r + b)) * (-1 + dp[r][b - 1])
            dp[r][b] = max(0, expected)
    
    return dp